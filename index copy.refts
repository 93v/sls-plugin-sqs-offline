import {
  SQS,
  // Lambda
} from "aws-sdk/clients/all";
// import { ClientConfiguration } from "aws-sdk/clients/lambda";
import { ChildProcess, spawn } from "child_process";
import { join } from "path";
import Serverless from "serverless";

import { IStacksMap, Stack } from "../types/additional-stack";
import { SQSConfig, SQSLaunchOptions, Stream } from "../types/sqs";
import { Provider } from "../types/provider";
import { ServerlessPluginCommand } from "../types/serverless-plugin-command";
import { writeFileSync } from "fs";

const getConfig = (
  port = "9234",
  statsPort = "9235",
  region = "us-west-2",
  accountId = "000000000000",
) => {
  return `
include classpath("application.conf")

# What is the outside visible address of this ElasticMQ node
# Used to create the queue URL (may be different from bind address!)
node-address {
  protocol = http
  host = localhost
  port = ${port}
  context-path = ""
}

rest-sqs {
  enabled = true
  bind-port = ${port}
  bind-hostname = "0.0.0.0"
  # Possible values: relaxed, strict
  sqs-limits = strict
}

rest-stats {
  enabled = true
  bind-port = ${statsPort}
  bind-hostname = "0.0.0.0"
}

# Should the node-address be generated from the bind port/hostname
# Set this to true e.g. when assigning port automatically by using port 0.
generate-node-address = false

queues {
  # See next sections
}

queues-storage {
  # See next sections
}

# Region and accountId which will be included in resource ids
aws {
  region = ${region}
  accountId = ${accountId}
}
`;
};

const SQS_LOCAL_PATH = join(__dirname, "../bin");

// const DEFAULT_READ_INTERVAL = 500;

// const pause = async (duration: number) =>
//   new Promise((r) => setTimeout(r, duration));

class ServerlessSQSOfflinePlugin {
   // private createDBStreamReadable = async (
  //   functionName: string,
  //   stream: Stream,
  // ) => {
  //   this.serverless.cli.log(
  //     `Create stream for ${functionName} on ${stream.tableName}`,
  //   );

  //   const tableDescription = await this.sqsClient
  //     ?.describeTable({ TableName: stream.tableName })
  //     .promise();

  //   const streamArn = tableDescription?.Table?.LatestStreamArn;

  //   if (streamArn == null) {
  //     return;
  //   }

  //   // Do not await to not block the rest of the serverless offline execution
  //   Promise.allSettled(
  //     streamDescription.StreamDescription.Shards.map(async (shard) => {
  //       if (shard.ShardId == null) {
  //         return;
  //       }

  //       if (this.dbStreamsClient == null) {
  //         return;
  //       }

  //       const shardIteratorType = stream.startingPosition || "TRIM_HORIZON";

  //       const getIteratorParams: GetShardIteratorInput = {
  //         ShardId: shard.ShardId,
  //         StreamArn: streamArn,
  //         ShardIteratorType: shardIteratorType,
  //       };

  //       if (this.sqsConfig.stream?.iterator) {
  //         getIteratorParams.ShardIteratorType = this.sqsConfig.stream?.iterator;
  //       } else if (this.sqsConfig.stream?.startAt) {
  //         getIteratorParams.ShardIteratorType = "AT_SEQUENCE_NUMBER";
  //         getIteratorParams.SequenceNumber = this.sqsConfig.stream?.startAt;
  //       } else if (this.sqsConfig.stream?.startAfter) {
  //         getIteratorParams.ShardIteratorType = "AFTER_SEQUENCE_NUMBER";
  //         getIteratorParams.SequenceNumber = this.sqsConfig.stream?.startAfter;
  //       } else {
  //         getIteratorParams.ShardIteratorType = "LATEST";
  //       }

  //       const iterator = await this.dbStreamsClient
  //         .getShardIterator(getIteratorParams)
  //         .promise();

  //       if (iterator.ShardIterator == null) {
  //         return;
  //       }

  //       let shardIterator = iterator.ShardIterator;

  //       // eslint-disable-next-line no-constant-condition
  //       while (true) {
  //         const getRecordsParams: GetRecordsInput = {
  //           ShardIterator: shardIterator,
  //           Limit: stream.batchSize || 20,
  //         };

  //         const records = await this.dbStreamsClient
  //           .getRecords(getRecordsParams)
  //           .promise();

  //         if (records.NextShardIterator != null) {
  //           shardIterator = records.NextShardIterator;
  //         }

  //         if (records.Records != null && records.Records.length) {
  //           const lambdaParams: ClientConfiguration = {
  //             endpoint: `http://localhost:${
  //               this.serverless.service.custom["serverless-offline"]
  //                 .lambdaPort || 3002
  //             }`,
  //             region: this.sqsConfig.start.region || "local",
  //           };

  //           const lambda = new Lambda(lambdaParams);

  //           const params = {
  //             FunctionName: `${this.serverless.service["service"]}-${this.serverless.service.provider.stage}-${functionName}`,
  //             InvocationType: "Event",
  //             Payload: JSON.stringify(records),
  //           };

  //           await lambda.invoke(params).promise();
  //         }

  //         await pause(
  //           this.sqsConfig.stream?.readInterval || DEFAULT_READ_INTERVAL,
  //         );
  //       }
  //     }),
  //   ).then((r) => {
  //     this.serverless.cli.log(r.length.toString());
  //   });
  // };

}

export = ServerlessSQSOfflinePlugin;
